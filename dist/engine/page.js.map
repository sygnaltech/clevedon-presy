{
  "version": 3,
  "sources": ["../../src/engine/page.ts"],
  "sourcesContent": ["\r\n\r\n// Determine Webflow breakpoint?\r\n\r\nexport class Page {\r\n\r\n    // Utility function to get a query parameter value by name\r\n        static getQueryParam(name: string): string | null {\r\n            const urlParams = new URLSearchParams(window.location.search);\r\n            return urlParams.get(name);\r\n        }\r\n    \r\n    \r\n        // Add a new async script to the page\r\n        // at the end of the body\r\n        static loadScript(url: string): void {\r\n            const script = document.createElement('script');\r\n            script.src = url;\r\n        //    script.async = true;\r\n            document.body.appendChild(script);\r\n        }\r\n    \r\n        // Add a new CSS file to the page\r\n        static loadCSS(url: string): void {\r\n            const link = document.createElement('link');\r\n            link.rel = 'stylesheet';\r\n            link.href = url;\r\n            document.head.appendChild(link);\r\n        }\r\n    \r\n        // Add a new Engine CSS file to the page\r\n        // Expected to be in the /dist/css/ dir \r\n        static loadEngineCSS(cssFileName: string): void {\r\n            // Get the URL of the currently executing script\r\n            let libPath = window.SSE.baseUrl;\r\n\r\n            // const currentScript = document.currentScript as HTMLScriptElement;\r\n            // if (currentScript) {\r\n                // const scriptURL = new URL(currentScript.src);\r\n                // const origin = scriptURL.origin;\r\n                // const path = scriptURL.pathname.substring(0, scriptURL.pathname.lastIndexOf('/'));\r\n    \r\n                const cssURL = `${libPath}/css/${cssFileName}`;\r\n                this.loadCSS(cssURL);\r\n            // } else {\r\n            //     console.error('Unable to determine the currently executing script.');\r\n            // }\r\n        }\r\n    \r\n        // Add a new Style element to the page\r\n        static loadStyle(css: string): void {\r\n            const style = document.createElement('style');\r\n        //    link.rel = 'stylesheet';\r\n        //    link.href = url;\r\n            style.innerText = css;\r\n            document.head.appendChild(style);\r\n        }\r\n    \r\n        // Replace an existing script source\r\n        static replaceScriptSource(element: HTMLScriptElement, newSrc: string): void {\r\n            element.src = newSrc;\r\n        }\r\n    \r\n        // Replace an existing CSS source\r\n        static replaceCSSLink(element: HTMLLinkElement, newHref: string): void {\r\n            element.href = newHref;\r\n        }\r\n    \r\n        // Function to prepend text to the document title in development mode\r\n        static prependToTitle(text: string): void {\r\n            document.title = `${text}${document.title}`;\r\n        }\r\n    \r\n        // Function to get the current script URL\r\n        static getCurrentScriptUrl(): string | null {\r\n            // Check if document.currentScript is supported\r\n            if (document.currentScript) {\r\n                // Cast to HTMLScriptElement and get the src attribute\r\n                const currentScript = document.currentScript as HTMLScriptElement;\r\n                return currentScript.src;\r\n            }\r\n            // For browsers that do not support document.currentScript\r\n            console.error(\"document.currentScript is not supported in this browser.\");\r\n            return null;\r\n        }\r\n    \r\n        static getCurrentScriptBaseUrl(): string | undefined {\r\n            // Get the URL of the currently executing script\r\n            const currentScript = document.currentScript as HTMLScriptElement;\r\n            if (currentScript) {\r\n                const scriptURL = new URL(currentScript.src);\r\n                const origin = scriptURL.origin;\r\n                const path = scriptURL.pathname.substring(0, scriptURL.pathname.lastIndexOf('/'));\r\n    \r\n                const baseURL = `${origin}${path}`;\r\n                return baseURL; \r\n            } else {\r\n                console.error('Unable to determine the currently executing script.');\r\n            }\r\n\r\n            return undefined; \r\n        }\r\n\r\n    \r\n        static findAncestorWithAttribute(element: HTMLElement, attributeName: string): HTMLElement | null {\r\n            let currentElement: HTMLElement | null = element;\r\n    \r\n            while (currentElement) {\r\n                if (currentElement.hasAttribute(attributeName)) {\r\n                    return currentElement;\r\n                }\r\n                currentElement = currentElement.parentElement;\r\n            }\r\n    \r\n            return null;\r\n        }\r\n    \r\n        static getAncestorAttributeValue(element: HTMLElement, attributeName: string): string | null {\r\n            let currentElement: HTMLElement | null = element;\r\n    \r\n            while (currentElement) {\r\n                if (currentElement.hasAttribute(attributeName)) {\r\n                    return currentElement.getAttribute(attributeName);\r\n                }\r\n                currentElement = currentElement.parentElement;\r\n            }\r\n    \r\n            return null;\r\n        }\r\n    \r\n        static hasAncestorWithAttribute(element: HTMLElement, attributeName: string): boolean {\r\n            return this.findAncestorWithAttribute(element, attributeName) !== null;\r\n        }\r\n    \r\n        static convertToPixels(value: string, contextElement: HTMLElement = document.documentElement): number {\r\n            // Parse the numeric value and unit, including negative values\r\n            const match = value.match(/^(-?\\d+\\.?\\d*)(rem|em|px|vh|vw|%)$/);\r\n            if (!match) throw new Error('Invalid value format');\r\n    \r\n            const [, amountStr, unit] = match;\r\n            const amount = parseFloat(amountStr);\r\n    \r\n            // Convert based on the unit\r\n            switch (unit) {\r\n                case 'px':\r\n                    return amount;\r\n                case 'rem':\r\n                    return amount * parseFloat(getComputedStyle(document.documentElement).fontSize);\r\n                case 'em':\r\n                    // For 'em', it's relative to the font-size of the context element.\r\n                    return amount * parseFloat(getComputedStyle(contextElement).fontSize);\r\n                case 'vh':\r\n                    return amount * window.innerHeight / 100;\r\n                case 'vw':\r\n                    return amount * window.innerWidth / 100;\r\n                case '%':\r\n                    // For %, it's relative to the parent element's size. This can be tricky as it depends on the property (width, height, font-size, etc.).\r\n                    // In this example, we'll use it relative to the width of the context element, but you might need to adjust based on your specific use case.\r\n                    return amount * contextElement.clientWidth / 100;\r\n                default:\r\n                    throw new Error('Unsupported unit');\r\n            }\r\n        }\r\n    \r\n        /*\r\n        // Example usage:\r\n        const pixelValue = convertToPixels(\"10vh\");\r\n        console.log(pixelValue);\r\n        */\r\n    \r\n        static async getResponseHeader(headerName: string, url: string | undefined = undefined): Promise<string | undefined> {\r\n    \r\n            const headers: Headers | undefined = await this.getResponseHeaders(url);\r\n    \r\n            if(!headers)\r\n                return undefined;\r\n    \r\n            if(!headers.has(headerName)) \r\n                return undefined;\r\n    \r\n            return headers.get(headerName) || undefined;\r\n    \r\n        }\r\n    \r\n        // Function to check if the reverse proxy header is present\r\n        static async getResponseHeaders(url: string | undefined = undefined): Promise<Headers | undefined> {\r\n            try {\r\n    \r\n                if(!url) {\r\n                    url = window.location.href\r\n                }\r\n    \r\n                const response = await fetch(url, {\r\n                    method: 'HEAD', // Only fetch headers\r\n                });\r\n    \r\n                return response.headers;\r\n    \r\n            } catch (error) {\r\n                console.error('Error checking reverse proxy header:', error);\r\n            }\r\n    \r\n            return undefined;\r\n        }\r\n    \r\n    }\r\n    \r\n    \r\n    "],
  "mappings": "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",
  "names": []
}

{
  "version": 3,
  "sources": ["../src/wfu-cms-select.ts", "../src/engine/core.ts", "../src/site.ts"],
  "sourcesContent": ["\n\n\nconst CMS_SELECT = \"wfu-cmsselect\"; \n\nconst CMS_SELECT_DATA = \"wfu-cmsselect-data\"; \n\nconst CMS_SELECT_TEXT = \"wfu-cmsselect-text\"; \nconst CMS_SELECT_VALUE = \"wfu-cmsselect-value\"; \n\n\n\nexport class Sa5CmsSelect {\n\n    //  modelDropdown: WebflowDropdown; \n    \n    constructor() {\n    }\n\n    initAll() {\n        // Get all elements with the custom attribute `wfu-cmsselect`\n        const cmsSelectElements = document.querySelectorAll(`[${CMS_SELECT}]`);\n        \n        // Iterate over each `wfu-cmsselect` element\n        cmsSelectElements.forEach(selectElement => {\n            const dataIdentifier = selectElement.getAttribute(CMS_SELECT);\n\n            if (dataIdentifier) {\n                // Find matching data elements with the custom attribute `wfu-cmsselect-data` and the same value\n                const dataElements = document.querySelectorAll(`[${CMS_SELECT_DATA}=\"${dataIdentifier}\"]`);\n\n                dataElements.forEach(dataElement => {\n                    // Find child elements with `wfu-cmsselect-text` and optionally `wfu-cmsselect-value`\n                    const textElements = dataElement.querySelectorAll(`[${CMS_SELECT_TEXT}]`);\n\n                    textElements.forEach(textElement => {\n                        const textValue = textElement.getAttribute(CMS_SELECT_TEXT);\n                        const optionValue = textElement.getAttribute(CMS_SELECT_VALUE);\n\n                        if (textValue) {\n                            // Create an option element\n                            const optionElement = document.createElement('option');\n                            optionElement.textContent = textValue;\n\n                            // Set the option value if it exists\n                            if (optionValue) {\n                                optionElement.value = optionValue;\n                            }\n\n                            // Append the option to the `wfu-cmsselect` element\n                            (selectElement as HTMLSelectElement).appendChild(optionElement);\n                        }\n                    });\n                });\n            }\n        });\n    }\n\n}\n", "\n\n// Determine Webflow breakpoint?\n\n\n// Utility function to get a query parameter value by name\nexport function getQueryParam(name: string): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get(name);\n}\n\n\n// Add a new async script to the page\n// at the end of the body\nexport function loadScript(url: string): void {\n    const script = document.createElement('script');\n    script.src = url;\n//    script.async = true;\n    document.body.appendChild(script);\n}\n\n// Add a new CSS file to the page\nexport function loadCSS(url: string): void {\n    const link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.href = url;\n    document.head.appendChild(link);\n}\n\n// Add a new Engine CSS file to the page\n// Expected to be in the /dist/css/ dir \nexport function loadEngineCSS(cssFileName: string): void {\n    // Get the URL of the currently executing script\n    const currentScript = document.currentScript as HTMLScriptElement;\n    if (currentScript) {\n        const scriptURL = new URL(currentScript.src);\n        const origin = scriptURL.origin;\n        const path = scriptURL.pathname.substring(0, scriptURL.pathname.lastIndexOf('/'));\n\n        const cssURL = `${origin}${path}/css/${cssFileName}`;\n        loadCSS(cssURL);\n    } else {\n        console.error('Unable to determine the currently executing script.');\n    }\n}\n\n// Add a new Style element to the page\nexport function loadStyle(css: string): void {\n    const style = document.createElement('style');\n//    link.rel = 'stylesheet';\n//    link.href = url;\n    style.innerText = css;\n    document.head.appendChild(style);\n}\n\n// Replace an existing script source\nexport function replaceScriptSource(element: HTMLScriptElement, newSrc: string): void {\n    element.src = newSrc;\n}\n\n// Replace an existing CSS source\nexport function replaceCSSLink(element: HTMLLinkElement, newHref: string): void {\n    element.href = newHref;\n}\n\n// Function to prepend text to the document title in development mode\nexport function prependToTitle(text: string): void {\n    document.title = `${text}${document.title}`;\n}\n\n// Function to get the current script URL\nexport function getCurrentScriptUrl(): string | null {\n    // Check if document.currentScript is supported\n    if (document.currentScript) {\n        // Cast to HTMLScriptElement and get the src attribute\n        const currentScript = document.currentScript as HTMLScriptElement;\n        return currentScript.src;\n    }\n    // For browsers that do not support document.currentScript\n    console.error(\"document.currentScript is not supported in this browser.\");\n    return null;\n}\n\n\nexport function findAncestorWithAttribute(element: HTMLElement, attributeName: string): HTMLElement | null {\n    let currentElement: HTMLElement | null = element;\n\n    while (currentElement) {\n        if (currentElement.hasAttribute(attributeName)) {\n            return currentElement;\n        }\n        currentElement = currentElement.parentElement;\n    }\n\n    return null;\n}\n\nexport function getAncestorAttributeValue(element: HTMLElement, attributeName: string): string | null {\n    let currentElement: HTMLElement | null = element;\n\n    while (currentElement) {\n        if (currentElement.hasAttribute(attributeName)) {\n            return currentElement.getAttribute(attributeName);\n        }\n        currentElement = currentElement.parentElement;\n    }\n\n    return null;\n}\n\nexport function hasAncestorWithAttribute(element: HTMLElement, attributeName: string): boolean {\n    return findAncestorWithAttribute(element, attributeName) !== null;\n}\n\nexport function convertToPixels(value: string, contextElement: HTMLElement = document.documentElement): number {\n    // Parse the numeric value and unit, including negative values\n    const match = value.match(/^(-?\\d+\\.?\\d*)(rem|em|px|vh|vw|%)$/);\n    if (!match) throw new Error('Invalid value format');\n\n    const [, amountStr, unit] = match;\n    const amount = parseFloat(amountStr);\n\n    // Convert based on the unit\n    switch (unit) {\n        case 'px':\n            return amount;\n        case 'rem':\n            return amount * parseFloat(getComputedStyle(document.documentElement).fontSize);\n        case 'em':\n            // For 'em', it's relative to the font-size of the context element.\n            return amount * parseFloat(getComputedStyle(contextElement).fontSize);\n        case 'vh':\n            return amount * window.innerHeight / 100;\n        case 'vw':\n            return amount * window.innerWidth / 100;\n        case '%':\n            // For %, it's relative to the parent element's size. This can be tricky as it depends on the property (width, height, font-size, etc.).\n            // In this example, we'll use it relative to the width of the context element, but you might need to adjust based on your specific use case.\n            return amount * contextElement.clientWidth / 100;\n        default:\n            throw new Error('Unsupported unit');\n    }\n}\n\n\n/*\n// Example usage:\nconst pixelValue = convertToPixels(\"10vh\");\nconsole.log(pixelValue);\n*/\n\nasync function getResponseHeader(headerName: string, url: string | undefined = undefined): Promise<string | undefined> {\n\n    const headers: Headers | undefined = await getResponseHeaders(url);\n\n    if(!headers)\n        return undefined;\n\n    if(!headers.has(headerName)) \n        return undefined;\n\n    return headers.get(headerName) || undefined;\n\n}\n\n// Function to check if the reverse proxy header is present\nasync function getResponseHeaders(url: string | undefined = undefined): Promise<Headers | undefined> {\n    try {\n\n        if(!url) {\n            url = window.location.href\n        }\n\n        const response = await fetch(url, {\n            method: 'HEAD', // Only fetch headers\n        });\n\n        return response.headers;\n\n    } catch (error) {\n        console.error('Error checking reverse proxy header:', error);\n    }\n\n    return undefined;\n}\n\n", "\n/*\n * Site\n */\n\n// import gsap from 'gsap'; \nimport { Sa5CmsSelect } from './wfu-cms-select';\nimport { IRouteHandler } from \"./engine/routeDispatcher\";\nimport { loadCSS, loadEngineCSS } from \"./engine/core\";\n \n\nexport class Site implements IRouteHandler {\n\n//  modelDropdown: WebflowDropdown; \n\n  constructor() {\n  }\n\n  setup() {\n\n    loadEngineCSS(\"site.css\"); \n   \n  }\n\n  exec() {\n\n//    console.log(\"Site.\"); \n\n    const cmsSelect = new Sa5CmsSelect();\n    cmsSelect.initAll(); \n\n    // const churchSelect = document.getElementById('church') as HTMLSelectElement;\n  \n    // if (churchSelect) {\n    //   churchSelect.addEventListener('change', () => {\n    //     const selectedChurch = churchSelect.value;\n\n\n\n      // Find all elements with the custom attribute `site-church-selector`\n      const churchSelectors = document.querySelectorAll('[site-church-selector]') as NodeListOf<HTMLSelectElement>;\n\n      // Update each found select element to match the selected value\n      churchSelectors.forEach(selectElement => {\n        // Find the option with the matching value\n        // const matchingOption = Array.from(selectElement.options).find(option => option.value === selectedChurch);\n\n        // if (matchingOption) {\n        //   // Set the select element's value to the matching option's value\n        //   selectElement.value = matchingOption.value;\n          \n        //   // const changeEvent = new Event('change', { bubbles: true, cancelable: true });\n        //   // selectElement.dispatchEvent(changeEvent);\n\n        //   const inputEvent = new Event('input', { bubbles: true });\n        //   selectElement.dispatchEvent(inputEvent);\n        // }\n      });\n\n\n//        console.log(`Selected church: ${selectedChurch}`);\n\n// site-church-selector\n\n\n//      });\n    // } else {\n    //   console.error('Select element with ID \"church\" not found.');\n    // }\n\n  }\n\n}\n"],
  "mappings": ";;;AAGA,MAAM,aAAa;AAEnB,MAAM,kBAAkB;AAExB,MAAM,kBAAkB;AACxB,MAAM,mBAAmB;AAIlB,MAAM,eAAN,MAAmB;AAAA,IAItB,cAAc;AAAA,IACd;AAAA,IAEA,UAAU;AAEN,YAAM,oBAAoB,SAAS,iBAAiB,IAAI,aAAa;AAGrE,wBAAkB,QAAQ,mBAAiB;AACvC,cAAM,iBAAiB,cAAc,aAAa,UAAU;AAE5D,YAAI,gBAAgB;AAEhB,gBAAM,eAAe,SAAS,iBAAiB,IAAI,oBAAoB,kBAAkB;AAEzF,uBAAa,QAAQ,iBAAe;AAEhC,kBAAM,eAAe,YAAY,iBAAiB,IAAI,kBAAkB;AAExE,yBAAa,QAAQ,iBAAe;AAChC,oBAAM,YAAY,YAAY,aAAa,eAAe;AAC1D,oBAAM,cAAc,YAAY,aAAa,gBAAgB;AAE7D,kBAAI,WAAW;AAEX,sBAAM,gBAAgB,SAAS,cAAc,QAAQ;AACrD,8BAAc,cAAc;AAG5B,oBAAI,aAAa;AACb,gCAAc,QAAQ;AAAA,gBAC1B;AAGA,gBAAC,cAAoC,YAAY,aAAa;AAAA,cAClE;AAAA,YACJ,CAAC;AAAA,UACL,CAAC;AAAA,QACL;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EAEJ;;;ACpCO,WAAS,QAAQ,KAAmB;AACvC,UAAM,OAAO,SAAS,cAAc,MAAM;AAC1C,SAAK,MAAM;AACX,SAAK,OAAO;AACZ,aAAS,KAAK,YAAY,IAAI;AAAA,EAClC;AAIO,WAAS,cAAc,aAA2B;AAErD,UAAM,gBAAgB,SAAS;AAC/B,QAAI,eAAe;AACf,YAAM,YAAY,IAAI,IAAI,cAAc,GAAG;AAC3C,YAAM,SAAS,UAAU;AACzB,YAAM,OAAO,UAAU,SAAS,UAAU,GAAG,UAAU,SAAS,YAAY,GAAG,CAAC;AAEhF,YAAM,SAAS,GAAG,SAAS,YAAY;AACvC,cAAQ,MAAM;AAAA,IAClB,OAAO;AACH,cAAQ,MAAM,qDAAqD;AAAA,IACvE;AAAA,EACJ;;;ACjCO,MAAM,OAAN,MAAoC;AAAA,IAIzC,cAAc;AAAA,IACd;AAAA,IAEA,QAAQ;AAEN,oBAAc,UAAU;AAAA,IAE1B;AAAA,IAEA,OAAO;AAIL,YAAM,YAAY,IAAI,aAAa;AACnC,gBAAU,QAAQ;AAWhB,YAAM,kBAAkB,SAAS,iBAAiB,wBAAwB;AAG1E,sBAAgB,QAAQ,mBAAiB;AAAA,MAczC,CAAC;AAAA,IAaL;AAAA,EAEF;",
  "names": []
}
